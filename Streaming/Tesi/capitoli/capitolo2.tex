%license:BSD-3-Clause
%copyright-holders:Michele Maione
%============================================================
%
%	Piattaforma di cloud gaming per giochi arcade
%
%============================================================

\chapter{Architettura del sistema}
%In questa sezione si deve descrivere l’obiettivo della ricerca, le problematiche affrontate ed eventuali definizioni preliminari nel caso la tesi sia di carattere teorico.
In questo capitolo verrà descritto il sistema proposto, il MAME e le sue funzioni di: rendering, missaggio audio e gestione dell'input utente.



\section{Sistema proposto}
L'esigenza per la quale nasce questo progetto è far conoscere alle nuove generazioni i videogiochi che hanno fatto la storia e dare la possibilità di poter giocare ancora a macchine che ormai hanno cessato di funzionare per motivi di obsolescenza, sfruttando due tecnologie entrate a far parte della quotidianità, lo streaming e il cloud computing. In questo lavoro si propone la creazione di una piattaforma di cloud gaming, che permette lo streaming audio-video direttamente e su richiesta dei videogiochi, da un server remoto, ad un client (computer, console, telefono). Per far ciò verrà ampliato il software MAME (rilasciato sotto licenza GNU-GPL) che è in grado di emulare oltre 7.000 giochi arcade. Le caratteristiche principali del progetto, che sono state vincolanti nella scelta delle tecnologie da utilizzare, sono la portabilità e la possibilità di utilizzare il sistema senza dover installare software aggiuntivi, e per questi vincoli, lato client, la scelta è ricaduta sul browser web.

Il sistema è stato progettato con un'ottica incentrata sull'utilizzo in LAN con l'utenza connessa tramite WiFi, ad esempio in stand di retro-gaming ad eventi di informatica e videogiochi, in aziende come servizio di svago per i clienti in sala d'attesa e per i dipendenti durante la pausa, ecc\dots, è importante ricordare che i videogiochi, nonostante siano stati pensati come fonte d'intrattenimento, migliorano diversi tipi di abilità chiave: abilità sociali e intellettuali, riflessi e concentrazione \parencite{Use_of_Cloud_Gaming_in_Education}; per questo motivo la piattaforma può essere installata anche nelle scuole. La tecnologia di streaming scelta è stata WebSocket per i seguenti motivi: in questo contesto la differenza di velocità tra TCP e RTP può essere trascurata, è un protocollo di comunicazione standardizzato dal 2011, è pienamente supportato da tutti i browser moderni, ha una latenza inferiore rispetto ad HLS e DASH, è semplice da instanziare e non richiede l'utilizzo di protocolli aggiuntivi o configurazioni complesse a differenza di WebRTC.

Come mostrato in Fig. \ref{fig:proposed_system} il sistema è costituito dal server di gioco (Linux, Windows o macOS), su cui è installato il MAME CGP con le rom dei giochi ed una pagina HTML5 che funge da front-end. Il programma è in ascolto per connessioni WebSocket con parametri (per es.: il nome del gioco, l'ID del player, l'ID della partita, ecc\dots). Una volta stabilita la connessione, il server invia informazioni sulla risoluzione di rendering e avvia il gioco. Il rendering e il missaggio audio del gioco vengono generati utilizzando la libreria SDL, codificati e pacchettizzati nel contenitore MPEG-TS\footnote{MPEG-TS: MPEG transport stream, è un contenitore digitale per la trasmissione e l'archiviazione audio-video.} usando la libreria FFmpeg\footnote{FFmpeg è una suite open-source di librerie e programmi per la gestione di video, audio, e altri file multimediali e stream.} e inviati tramite WebSocket al client.

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/proposed_system}
	\caption{Panoramica del sistema}
	\label{fig:proposed_system}
\end{figure}

Lato client vari script si occupano di: decodificare i dati audio-video ricevuti, catturare e inviare l'input dell'utente (sia dalla tastiera che dal gamepad) al server tramite WebSocket.

Nel prossima sezione introdurremo il software MAME su cui si basa questo progetto.

\section{MAME}
Multiple Arcade Machine Emulator (MAME) è un progetto open-source (GNU-GPL) di Nicola Salmoria. La prima versione del MAME risale al febbraio 1997 ed è attualmente supportato da una vasta comunità di sviluppatori da tutto il mondo. Lo scopo principale è quello di essere un riferimento al funzionamento interno delle macchine emulate, sia per scopi educativi che per scopi di conservazione, al fine di evitare che il software storico scompaia per motivi di obsolescenza. Il progetto è stato realizzato in C++, inizialmente usando solamente la libreria standard e poi successivamente, negli anni, sono state aggiunte al progetto varie librerie open-source per estenderne le funzionalità. Originariamente era disponibile solo per MS-DOS ma grazie alla vasta comunità di sviluppatori è stato portato per i sistemi Windows e Unix-like \parencite{MAME}. Logicalmente è suddiviso in quattro macro categorie, come mostrato in Fig. \ref{fig:mame_arch}:

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/mame_arch}
	\caption{MAME, diagramma dei packages}
	\label{fig:mame_arch}
\end{figure}

\begin{itemize}
	\item "Core" in cui ci sono i sotto-progetti indipendenti dal sistema e dal device emulato tra cui il programma principale (progetto main), il front-end grafico, il motore di emulazione (progetto emu), le librerie comuni (lib) ed i sorgenti delle librerie esterne (3rdparty);
	\item "OSD" contenente le funzionalità sia dipendenti dal sistema operativo come macOS, Windows, UWP ed SDLMAME, sia i moduli (progetto modules) di input, audio e video dipendenti da altre librerie come OpenGL, DirectX, SDL, CoreAudio, XAudio, XInput, ecc\dots;
	\item "Devices" che contiene per ogni device emulato (ad esempio il Capcom CP System III) le classi che gestiscono le informazioni della macchina ed emulano cpu, bus, video, audio e i dischi (progetto formats);
	\item "Tools \& Test" che contiene varie utility per la gestione delle rom e per la fase di testing.
\end{itemize}

\textit{Il progetto ha una struttura modulare}, schematizzata in Fig. \ref{fig:mame_schema_moduli_d}, \textit{formato da un nucleo centrale che dirige le operazioni, gestisce l’interfaccia utente e mette a disposizione dei driver un buon numero di funzioni d'uso comune. Il nucleo delega a moduli esterni l'emulazione dei vari tipi di CPU e di chip audio supportati. In pratica il nucleo fornisce un ambiente operativo specializzato nell'emulazione di videogiochi arcade, che i driver possono sfruttare con poco codice aggiuntivo. Spesso la maggior parte del contenuto di un driver è costituita da strutture dati, gestite direttamente dal nucleo. Il driver deve fornire codice solo per alcuni compiti specifici, ad esempio l'aggiornamento del video} \parencite{Il_progetto_MAME}.

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/mame_schema_moduli_d}
	\caption{Schema della struttura di MAME}
	\label{fig:mame_schema_moduli_d}
\end{figure}

Per quanto riguarda la portabilità, di cui c'è uno schema in Fig. \ref{fig:mame_architettura_full}, ci sono solo tre compilazioni native differenti e sono quella per macOS, Windows ed UWP\footnote{UWP: Universal Windows Platform è un'architettura applicativa della Microsoft per sviluppare applicazioni eseguibili su Windows 10, Xbox One e Hololens.}, in aggiunta c'è la compilazione SDLMAME\footnote{SDLMAME era un port del MAME che utilizzava solamente la libreria SDL. Nel 2010 è stato incluso ufficialmente nel progetto MAME.} in grado di funzionare su tutti i sistemi operativi supportati dalla libreria SDL. Quest'ultima è la compilazione obbligatoria per i sistemi Linux e per questo motivo è quella che si è scelta di utilizzare per questo server di cloud gaming.

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/mame_architettura_full}
	\caption{Librerie e interfacce utilizzate dal MAME sulle diverse piattaforme}
	\label{fig:mame_architettura_full}
\end{figure}

SDL (Simple DirectMedia Layer) è una libreria multipiattaforma che fornisce accesso di basso livello ad audio, tastiera, mouse, gamepad, hardware 3D e framebuffer 2D. Come mostrato in Fig. \ref{fig:mame_architettura_full} nello schema in alto, SDL è costruito sopra le API di visualizzazione video del sistema operativo (in arancione), le librerie di rendering 3D (in verde) e le librerie che si interfacciano alla scheda audio (in rosso) \parencite{SDL_Wiki}.

Nel prossimi tre paragrafi verrano descritti i tre moduli su cui sono state apportate delle modifiche per trasformare il MAME in una piattaforma di cloud gaming.


\subsection{Rendering}
Il rendering è il processo di generazione di un'immagine a partire dalla sua descrizione, che può essere sia in due dimensioni (2D) sia in tre (3D), tramite un software. Gli elementi di base del rendering 2D sono le textures\footnote{Una texture è un'immagine rappresentata come una matrice bidimensionale di pixel colorati (in inglese bitmap). Ogni pixel è rappresentato tramite una quaterna formata dai tre colori primari più un valore che ne indica la trasparenza (RGB + A); servono 4 bit per memorizzare ogni elemento della quaterna, quindi 32 in totale per un singolo pixel.} e le animazioni. Il motore grafico (il software che si occupa anche del rendering) prende gli elementi uno ad uno e li disegna nel framebuffer\footnote{Il framebuffer è uno spazio di memoria presente sulla scheda video in cui si memorizza l'immagine che verrà successivamente mostrata a video.} generando l'immagine finale \parencite{Efficient_2D_software_rendering}. Come mostrato in Fig. \ref{fig:rendering_pipeline}, questo processo è formato da quattro fasi \parencite{Computer_Vision_A_Modern_Approach}:

\begin{enumerate}
    \item Trasformazione di modellazione: tramite una trasformazione trasporta le primitive geometriche in un sistema di coordinate universali (\textit{world coordinate system});
    \item Clipping: ritaglia porzioni delle primitive al di fuori della finestra di visualizzazione;
    \item Trasformazione di vista: tramite una trasformazione ridiga detta "trasformazione di vista" trasporta le primiteve ritagliate dalle cordinate universali a quelle schermo (\textit{screen coordinate});
    \item \textit{Scan conversion}: attraverso algoritmi di rasterizzazione\footnote{La rasterizzazione è il processo di approssimazione delle primitive geometriche in immagini bitmap.} genera l'immagine finale.
\end{enumerate}

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/rendering_pipeline}
	\caption{Pipeline di rendering 2D}
	\label{fig:rendering_pipeline}
\end{figure}

Il MAME è in grado di emulare giochi sia 2D che 3D (es.: Tekken della Namco) ma sia per la volontà di emulare fedelmente l'hardware della macchina sia perché le varie schede ed API grafiche delle macchine emulate non lavorano esattamente come quelle moderne (es.: i poligoni della mesh utilizzano i rettangoli al posto dei triangoli) tutta la fase di rendering viene eseguita via software, per questo motivo ciò che viene inviato alla libreria grafica è un insieme di primitive e texture da disegnare sia nel caso di giochi 2D che 3D come spiegato nella FAQ ufficiale nel capitolo sulle performance: \textit{«There are many things that are difficult to emulate without expending a large amount of CPU power. Some specific examples are: Games with 3D graphics. As of this writing, MAME does not pass polygons down to the video card of your system; instead, it renders all 3D graphics by hand in software. Although this code is generally optimized to take advantage of multiple CPUs, it is still quite taxing to do this. Some 3D games give you control of the output resolution; reducing it will reduce the CPU requirements.»} \parencite{MAME_FAQ_Performance}.

La UI del MAME viene renderizzata con le stesse procedure utilizzate per l'emulazione per cui è possibile effettuarne lo streaming ed utilizzarla al posto del front-end HTML.

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/class_renderingSDLFull}
	\caption{Diagramma delle classi relative al rendering}
	\label{fig:class_renderingSDLFull}
\end{figure}

Come detto precedentemente il MAME supporta varie librerie multimediali per la fase di rendering e di missaggio audio. In Fig. \ref{fig:mame_render_class_diagram} è visibile un diagramma delle classi relativo alla sola funzionalità di rendering da cui è stato estrapolato il diagramma parziale di Fig. \ref{fig:class_renderingSDLFull}. Dopo che è stata creata la finestra in cui verrà visualizzato il rendering, tramite la funzione \verb|osd_renderer::make_for_type| viene istanziata una delle classi per il rendering (es.: \verb|render_ogl|, \verb|render_d3d9|, \verb|renderer_sdl2|, ecc\dots) che comunica direttamente con la libreria grafica. Alla creazione di una di queste classi viene chiamato il metodo \verb|osd_renderer::create| che si occupa di inizializzare il necessario per il rendering. Per ogni frame della macchina che viene emulato c'è una fase di disegno tramite il metodo \verb|osd_renderer::draw|.

La classe che si occupa del rendering utilizzando la libreria SDL è \verb|renderer_sdl2| che utilizza le seguenti funzioni SDL:

\begin{itemize}	
	\item \verb|SDL_CreateRenderer|: Crea un contesto di rendering 2D per una finestra;
	\item \verb|SDL_SetRenderDrawColor|: Imposta il colore utilizzato per le operazioni di disegno;
	\item \verb|SDL_RenderFillRect|: Riempe un rettangolo con il colore di disegno corrente; è usato per disegnare la primitiva \verb|QUAD|;
	\item \verb|SDL_RenderDrawLine|: Disegna una linea con il colore di disegno corrente; è usato per disegnare la primitiva \verb|LINE|;
	\item \verb|SDL_RenderPresent|: Aggiorna il contesto di rendering con il framebuffer corrente.
\end{itemize}

Di cui la prima viene utilizzata durante la fase di inizializzazione nella funzione \verb|create|, mentre le altre vengono utilizzate durante la fase di disegno nella funzione \verb|draw|.

\subsection{Missaggio audio}
Il missaggio audio è quel procedimento con cui due o più campioni audio sono fusi in un unico output sonoro. Attualmente il MAME emula una cinquantina di chip audio, ma per alcuni giochi antecedenti al 1982 invece di emulare i circuiti si sono semplicemente utilizzati i suoni registrati dalla scheda originale perché il sonoro era prodotto mediante circuiti analogici, la cui emulazione è più complessa. Sono supportate cinque librerie per la gestione della scheda audio che sono: SDL, DirectAudio (dalla libreria DirectX) e XAudio2 per Windows, Core Audio per macOS, PortAudio per Windows e macOS. \parencite{Il_progetto_MAME}.

La classe che si occupa del missaggio audio utilizzando la libreria SDL è \verb|sound_sdl2| che utilizza le seguenti funzioni SDL:

\begin{itemize}	
	\item \verb|SDL_OpenAudio|: Apre il dispositivo audio;
	\item \verb|SDL_PauseAudio|: Mette in pausa o ripristina la riproduzione audio;
	\item \verb|SDL_CloseAudio|: Interrompere l'elaborazione audio e chiude il dispositivo audio.
\end{itemize}

La funzione \verb|SDL_OpenAudio| utilizza la struttura \verb|SDL_AudioSpec| che contiene informazioni come il formato del buffer audio, il numero di canali, i bit per canale, ecc\dots, e un puntatore ad una funzione di callback asincrona; questa funzione è molto importante perché è quella che effettivamente viene utilizzata per riprodurre un suono. Come è visibile in Fig. \ref{fig:class_mixingSDLFull} la funzione \verb|sdl_callback| ha due parametri \verb|stream| e \verb|len| che sono rispettivamente il buffer da riempire con il suono e la dimensione del buffer \parencite{FocusOnSDL}. Il MAME utilizza un buffer ad anello (classe \verb|ring_buffer|) in cui la macchina emulata aggiunge campioni audio e da cui la funzione \verb|sdl_callback| li rimuove e li copia nel vettore \verb|stream|.

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/class_mixingSDLFull}
	\caption{Diagramma delle classi relative al missaggio audio}
	\label{fig:class_mixingSDLFull}
\end{figure}

\subsection{Gestione input}
Anyway, an event is simply something that happens, such as a key press, a key release, or mouse movement. Pretty much anything that occurs to the computer that you might want to react to is an event.
Depending on the event, you will want to know not only what event occurred, but also some extra data about the event to help you decide what to make the program do. For example, when a key is pressed, you want to know not only that a key was pressed, but also which key was pressed.

There are 16 different types of events that you can receive using SDL.
For organization and presentation purposes, I’ve divided these 16 events into four categories—keyboard, mouse, joystick, and system.

Keyboard events take two forms—key presses and key releases.
In addition to the simple “a key has been pressed” or “a key has been released” data, a keyboard event also contains other information, such as which key has been pressed. This information includes a scan code, a special SDL key identifier, and (optionally) the ASCII or Unicode equivalent for that key. It also contains the shift state of the keyboard, such as whether Shift, Ctrl, or Alt is being held down. You will have all of the information you could possibly need to react to keyboard events.

The mouse generates three different events. One is a mouse motion event, which occurs any time the mouse is moved. The other two are mouse button events—one for when a mouse button is pressed, and the other for when a mouse button is released.
In a mouse motion event, the extra data includes the current state of the mouse buttons (which is important if you are using the mouse to drag items from one place to another), the position of the mouse, and how far the mouse has moved since the last mouse event.
In mouse button events, the extra data includes which button has changed its state, the state of all of the buttons, and the position at which this button change occurred.

Although joysticks are covered in Chapter 6, “SDL Joysticks,” the events they generate are covered here. Joysticks generate events just like any other input device. They can generate up to five different events, depending on the joystick. These events include axis events, button events (one for a press and one for a release), hat events, and trackball events. Naturally, if the joystick in question doesn’t have a hat or trackball, it won’t generate those types of events.
Most of the joystick events are quite similar. Since there is no telling how many joysticks a user can have on their system, the extra information with the event always includes which device and which axis, button, hat, or trackball generated the event. Also, there is always a value to which the axis, button, hat, or trackball has changed, and that information is also stored with the joystick event.


Now that you have an overview of what sort of information you can get from the event-handling subsystem, you need to know how to go about getting that information. There are essentially three ways to grab event/input information from the SDL event-handling subsystem—by waiting, polling, or directly gathering.

In most non-game applications, the program typically does absolutely nothing most of the time; it just sits there and waits for an event to occur. This is the event-driven model of input gathering. Although you probably won’t want to use this in most games, it is typically the method of input gathering that you will use if you make editors for your game levels.
With this method, most of the program’s time is spent waiting for something to happen. Once something occurs, the program reacts to it, typically redraws the screen or performs the appropriate task, and then goes back to waiting, ad infinitum.

Many games use the polling method of input gathering. The program checks often to see whether an event has occurred. If one has, the program reacts to it and looks for more events. If no event has occurred, the application will do something else for a moment (move the bad guys around, do animations, and so on) and then look for another event. With polling, you won’t miss any data because you are still responding to events.

The third way of gathering data is directly from the input devices themselves. At any time, you can see whether a particular key is up or down on the keyboard, where the mouse is, the state of the mouse buttons, and the various input states of joysticks. This is the totally hard-core way of gathering input; if it is done improperly, you can miss input.
Even if you are using the direct method of gathering information about input devices, you still need to poll the event queue \parencite{FocusOnSDL}.

%SDL_Event
%SDL_Joystick

%SDL_PollEvent
%SDL_PumpEvents

%SDL_JoystickOpen
%SDL_JoystickClose

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/class_input_device}
	\caption{Diagramma delle classi relative al missaggio audio}
	\label{fig:class_input_device}
\end{figure}

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\begin{figure}[H]
	\includegraphics[width=\linewidth]{immagini/class_input_module}
	\caption{Diagramma delle classi relative al missaggio audio}
	\label{fig:class_input_module}
\end{figure}


Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

%\parencite{SDL_game_development}
%\parencite{CPP_Primer}
%\parencite{Computer_Networking_and_the_Internet}
%\parencite{Ingegneria_del_software}
%\parencite{Understanding_the_Linux_Kernel}
%\parencite{Windows_Server_2012}